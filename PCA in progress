#Goes with PC_coreA_example.csv file

dat<-read.csv(file.choose())
head(dat)
core_dat <- subset(dat[1:15,1:3])
row.names(core_dat) <- core_dat$compounds
core_dat <- core_dat[,-1]
colnames(core_dat)[1] <- "atomic.no"
head(core_dat)

# core_dat is the real data set we are working with.


# Now we center the values in relation to their means without
# normalizing (scale = F) using the SD:

centered_dat <- as.data.frame(scale(core_dat, center=T, scale = F)) 
head(centered_dat)


# To mimic the operation in princomp() we use the original data (core_dat)
# to calculate the covariance:

C_core <- cov(core_dat) # C_coreovariance matrix
C_core


# And we use this variance (C_core) to calculate eigen() values:

core_values <- eigen(C_core)$values # Eigenvalues
core_values_matrix <- diag(2)*eigen(C_core)$values # Eigenvalues matrix
core_values_matrix

core_vectors <- eigen(C_core)$vectors # Eigenvectors matrix (2 x 2)
core_vectors

# Now we can calculate the score matrix manually and to do so
# we use for the first time the centered values.
# We will mixed here the eigen vectors calculated using the 
# ORIGINAL data with the CENTERED data.

#THE BIG FORMULA:

score_matrix <-  t((t(core_vectors)%*%t(centered_dat)))

colnames(score_matrix) <-c("V1","V2")

# Compared to matrix obtained manually:

head(score_matrix)

# ... to doing it automatically:

auto <- princomp(core_dat) # or


head(auto$scores)

# Iiiii...dentical!!!!!

# What about the eigen values obtained automatically...

princomp(covmat=C_core)$sd^2 # vs...

core_values #and...

prcomp(core_dat)$rotation # vs...

core_vectors

# Truly scaled would be 1/sd, and this is what we'll use TO PLOT
# the linear transformations:

scaled_dat <- scale(core_dat,scale=T,center=T)

# If we use the original eigen() results we'll get a mismatch.
# For instance calling...

head(scaled_dat)

# We get values between - 2 and 2, whereas...

core_values

# 53829.7896   110.8414

# Unplottable!!

# So we can use the core_vectors, but we need new values:

C_scaled <- cov(scaled_dat)

scaled_values <- eigen(C_scaled)$values

score_scaled <- t(t(core_vectors)%*%t(scaled_dat))

colnames(score_scaled) <-c("V1","V2")


# or, simply...

prcomp(core_dat, center = T, scale = T)$sdev^2

#To calculate the elative influence of eigenvalues, for instance:

eigen(C_core)$values[1]/sum(eigen(C_core)$values) * 100



#FIRST PLOT:

scaled_cent <- scale(core_dat, center = T, scale = T)

plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
     pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

# Overlap pertinent evectors

#e_vector1 <- c(auto$loadings[1,1],auto$loadings[2,1])
#e_vector2 <- c(auto$loadings[1,2],auto$loadings[2,2])

# Identical!

# Draw line subtended by eigenvectors:

abline(0, core_vectors[2,1]/core_vectors[1,1],col='red')
abline(0, core_vectors[2,2]/core_vectors[1,2],col='blue')

arrows(x0 = 0, y0 = 0, x1 = core_values1core_vectors[1,1], 
       y1 = core_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,2], 
       y1 = core_vectors[2,2],col="blue", lwd=2)


#Plot the lines from first evector to points

line1 <- c(0, core_vectors[2,1]/core_vectors[1,1])

perp.segment.coord <- function(x0, y0, line1){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the line1
  
  a <- line1[1]  #intercept
  b <- line1[2]  #slope
  
  x1 <- (x0 + b * y0 - a * b)/(1 + b^2)
  y1 <- a + b * x1
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

scaled_cent <- as.data.frame(scaled_cent)
ss <- perp.segment.coord(scaled_cent$atomic.no, scaled_cent$melting.point, line1)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ss$x0, x1 = ss$x1, y0 = ss$y0, y1 = ss$y1, col='red', lwd=2)


points(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
       pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

text(melting.point ~ atomic.no, 
     labels = as.factor(rownames(scaled_cent)), pos=3, data = scaled_cent)




# PLOT2:


plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
     pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

#Overlap pertinent evectors

abline(0, core_vectors[2,1]/core_vectors[1,1],col='red')
abline(0, core_vectors[2,2]/core_vectors[1,2],col='blue')

arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,1], y1 = core_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,2], y1 = core_vectors[2,2],col="blue", lwd=2)


line1a <- c(0, core_vectors[2,2]/core_vectors[1,2])
ssa <- perp.segment.coord(scaled_cent$atomic.no, scaled_cent$melting.point, line1a)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ssa$x0, x1 = ssa$x1, y0 = ssa$y0, y1 = ssa$y1, col='blue', lwd=2)

points(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
       pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

text(melting.point ~ atomic.no, 
     labels = as.factor(rownames(scaled_cent)), pos=3, data = scaled_cent)





# PLOT3:

#Now compare side-by-side with plotted first and second column Scores:

score <- as.data.frame(score_scaled)

plot(V2 ~ V1, col=as.factor(rownames(score_scaled)), pch = 19, 
     xlab='V1', ylab='V2', xlim=c(-2.2,2.2), ylim=c(-2.2,2.2), data=score)

abline(v=0, col = 'red')
abline(h=0, col='blue',lwd=2)


perp.segment.horiz <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- 0
  y1 <- y0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1 <- perp.segment.horiz(score[,1], score[,2])

segments(x0 = ss1$x0, x1 = ss1$x1, y0 = ss1$y0, y1 = ss1$y1, col='red', lwd=2)

text(V2 ~ V1, 
     labels = as.factor(rownames(score_scaled)), pos=3, data = score_scaled)



# PLOT 4:

plot(V2 ~ V1, col=as.factor(rownames(score_scaled)), pch = 19, 
     xlab='V1', ylab='V2', xlim=c(-2.2,2.2), ylim=c(-2.2,2.2), data=score)

abline(v=0, col = 'red')
abline(h=0, col='blue',lwd=2)


perp.segment.vert <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- x0
  y1 <- 0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1a <- perp.segment.vert(score[,1], score[,2])

segments(x0 = ss1a$x0, x1 = ss1a$x1, y0 = ss1a$y0, y1 = ss1a$y1, col='blue',lwd=2)


text(V2 ~ V1, 
     labels = as.factor(rownames(score_scaled)), pos=3, data = score_scaled)





##SEC_coreOND PART RESTORING THE DATA:



dat2 <- score
head(dat2)

#PLOT 5:


plot(V2 ~ V1, col = as.factor(rownames(dat2)), 
     xlim=c(-2.2,2.2), ylim=c(-2.2,2.2), pch = 19, data = dat2)



abline(0, core_vectors[2,1]/core_vectors[1,1],col='red', lwd=2)
abline(0, core_vectors[2,2]/core_vectors[1,2],col='blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,1], y1 = core_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,2], y1 = core_vectors[2,2],col="blue", lwd=2)

text(V2 ~ V1, 
     labels = as.factor(rownames(dat2)), pos=3, data = dat2)

# Rotate:

rot <- t(t(solve(vectors))%*%t(dat2))

rot1<- as.data.frame(rot)

colnames(rot1) <- c("Rot1","Rot2")

plot(Rot2 ~ Rot1, col = as.factor(rownames(rot1)),  xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),
     pch = 19,main="Data Rotation",data = rot1)



abline(0, core_vectors[2,1]/core_vectors[1,1],col='red', lwd=2)
abline(0, core_vectors[2,2]/core_vectors[1,2],col='blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,1], y1 = core_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_vectors[1,2], y1 = core_vectors[2,2],col="blue", lwd=2)

text(Rot2 ~ Rot1, 
     labels = as.factor(rownames(rot1)), pos=3, data = rot1)

# C_coreontract data

contract <- rot %*% solve(core_values_matrix)
contract_dat <- as.data.frame(contract)
colnames(contract_dat) <- c("Recons.1","Recons.2")
head(contract_dat)

plot(Recons.2 ~ Recons.1, col = as.factor(rownames(contract_dat)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19, main="Data C_coreontraction", 
     xlab="Reconstructed Atomic Number", ylab="Reconstructed melting.point",data = contract_dat)

abline(v=0,h=0, col = "dark gray")

abline(0, core_vectors[1,2]/core_vectors[1,1],col='red')
abline(0, core_vectors[2,1]/core_vectors[2,2],col='light blue',lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_values[1]*core_vectors[1,1], y1 = core_values[1]*core_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_values[2]*core_vectors[2,1], y1 = core_values[2]*core_vectors[2,2],col="blue", lwd=2)

with(contract_dat,text(Recons.2 ~ Recons.1, labels =as.factor(rownames(contract_dat)), pos=3))

plot(melting.point ~ atomic.no, col = as.factor(rownames(centered_dat)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19, main="Original Data",data = centered_dat)

abline(v=0,h=0, col = "dark gray")



abline(0, core_vectors[1,2]/core_vectors[1,1],col='red')
abline(0, core_vectors[2,1]/core_vectors[2,2],col='light blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = core_values[1]*core_vectors[1,1], y1 = core_values[1]*core_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = core_values[2]*core_vectors[2,1], y1 = core_values[2]*core_vectors[2,2],col="blue", lwd=2)
with(centered_dat,text(melting.point ~ atomic.no, labels = as.factor(rownames(centered_dat)), pos=3))
