#Goes with PCA_example.csv file

dat<-read.csv(file.choose())
head(dat)
dat1 <- subset(dat[1:15,1:3])
row.names(dat1) <- dat1$compounds
dat1 <- dat1[,-1]
colnames(dat1)[1] <- "atomic.no"
head(dat1)

scaled_dat <- as.data.frame(scale(dat1, center=T, scale = F)) 
head(scaled_dat)

C <- cov(dat1) # Covariance matrix
C

lambda <- eigen(C)$values # Eigenvalues
lambda_matrix <- diag(2)*eigen(C)$values # Eigenvalues matrix
lambda_matrix

e_vectors <- eigen(C)$vectors # Eigenvectors matrix (2 x 2)
e_vectors


#THE BIG FORMULA:

score_matrix <-  t((t(e_vectors)%*%t(scaled_dat)))

colnames(score_matrix) <-c("V1","V2")

# Truly scaled would be 1/sd:

vectors <- eigen(cov(scaled_dat))$vectors

score_scaled <- t((t(vectors)%*%t(scale(dat1,scale=T,center=T))))

colnames(score_scaled) <-c("V1","V2")

# Compared matrix obtained manually:

head(score_matrix)

# ... to doing it automatically:

auto <- princomp(dat1)

head(auto$scores)

#Iiiii...dentical!!!!!

#relative influence of eigenvalues, for instance PC1:

eigen(C)$values[1]/sum(eigen(C)$values) * 100

#FIRST PLOT:

scaled_cent <- scale(dat1, center = T, scale = T)

plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
     pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

# Overlap pertinent evectors

#e_vector1 <- c(auto$loadings[1,1],auto$loadings[2,1])
#e_vector2 <- c(auto$loadings[1,2],auto$loadings[2,2])

# Identical!

# Draw line subtended by eigenvectors:

abline(0, e_vectors[2,1]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,2]/e_vectors[1,2],col='blue')

arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,1], 
       y1 = e_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,2], 
       y1 = e_vectors[2,2],col="blue", lwd=2)


#Plot the lines from first evector to points

line1 <- c(0, e_vectors[2,1]/e_vectors[1,1])

perp.segment.coord <- function(x0, y0, line1){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the line1
  
  a <- line1[1]  #intercept
  b <- line1[2]  #slope
  
  x1 <- (x0 + b * y0 - a * b)/(1 + b^2)
  y1 <- a + b * x1
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

scaled_cent <- as.data.frame(scaled_cent)
ss <- perp.segment.coord(scaled_cent$atomic.no, scaled_cent$melting.point, line1)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ss$x0, x1 = ss$x1, y0 = ss$y0, y1 = ss$y1, col='red', lwd=2)


points(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
     pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

text(melting.point ~ atomic.no, 
     labels = as.factor(rownames(scaled_cent)), pos=3, data = scaled_cent)




# PLOT2:


plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
     pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

#Overlap pertinent evectors

abline(0, e_vectors[2,1]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,2]/e_vectors[1,2],col='blue')

arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,1], y1 = e_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,2], y1 = e_vectors[2,2],col="blue", lwd=2)


line1a <- c(0, e_vectors[2,2]/e_vectors[1,2])
ssa <- perp.segment.coord(scaled_cent$atomic.no, scaled_cent$melting.point, line1a)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ssa$x0, x1 = ssa$x1, y0 = ssa$y0, y1 = ssa$y1, col='blue', lwd=2)

points(melting.point ~ atomic.no, col = as.factor(rownames(scaled_cent)), 
     pch = 19, xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),data = scaled_cent)

text(melting.point ~ atomic.no, 
     labels = as.factor(rownames(scaled_cent)), pos=3, data = scaled_cent)





# PLOT3:

#Now compare side-by-side with plotted first and second column Scores:

score <- as.data.frame(score_scaled)

plot(V2 ~ V1, col=as.factor(rownames(score_scaled)), pch = 19, 
     xlab='V1', ylab='V2', xlim=c(-2.2,2.2), ylim=c(-2.2,2.2), data=score)

abline(v=0, col = 'red')
abline(h=0, col='blue',lwd=2)


perp.segment.horiz <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- 0
  y1 <- y0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1 <- perp.segment.horiz(score[,1], score[,2])

segments(x0 = ss1$x0, x1 = ss1$x1, y0 = ss1$y0, y1 = ss1$y1, col='red', lwd=2)

text(V2 ~ V1, 
     labels = as.factor(rownames(score_scaled)), pos=3, data = score_scaled)



# PLOT 4:

plot(V2 ~ V1, col=as.factor(rownames(score_scaled)), pch = 19, 
     xlab='V1', ylab='V2', xlim=c(-2.2,2.2), ylim=c(-2.2,2.2), data=score)

abline(v=0, col = 'red')
abline(h=0, col='blue',lwd=2)


perp.segment.vert <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- x0
  y1 <- 0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1a <- perp.segment.vert(score[,1], score[,2])

segments(x0 = ss1a$x0, x1 = ss1a$x1, y0 = ss1a$y0, y1 = ss1a$y1, col='blue',lwd=2)


text(V2 ~ V1, 
     labels = as.factor(rownames(score_scaled)), pos=3, data = score_scaled)





##SECOND PART RESTORING THE DATA:



dat2 <- score
head(dat2)

#PLOT 5:


plot(V2 ~ V1, col = as.factor(rownames(dat2)), 
     xlim=c(-2.2,2.2), ylim=c(-2.2,2.2), pch = 19, data = dat2)



abline(0, e_vectors[2,1]/e_vectors[1,1],col='red', lwd=2)
abline(0, e_vectors[2,2]/e_vectors[1,2],col='blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,1], y1 = e_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,2], y1 = e_vectors[2,2],col="blue", lwd=2)

text(V2 ~ V1, 
     labels = as.factor(rownames(dat2)), pos=3, data = dat2)

# Rotate:

rot <- t(t(solve(vectors))%*%t(dat2))

rot1<- as.data.frame(rot)

colnames(rot1) <- c("Rot1","Rot2")

plot(Rot2 ~ Rot1, col = as.factor(rownames(rot1)),  xlim=c(-2.2,2.2), ylim=c(-2.2,2.2),
     pch = 19,main="Data Rotation",data = rot1)



abline(0, e_vectors[2,1]/e_vectors[1,1],col='red', lwd=2)
abline(0, e_vectors[2,2]/e_vectors[1,2],col='blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,1], y1 = e_vectors[2,1],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,2], y1 = e_vectors[2,2],col="blue", lwd=2)

text(Rot2 ~ Rot1, 
     labels = as.factor(rownames(rot1)), pos=3, data = rot1)

# Contract data

contract <- rot %*% solve(lambda_matrix)
contract_dat <- as.data.frame(contract)
colnames(contract_dat) <- c("Recons.1","Recons.2")
head(contract_dat)

plot(Recons.2 ~ Recons.1, col = as.factor(rownames(contract_dat)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19, main="Data Contraction", 
     xlab="Reconstructed Atomic Number", ylab="Reconstructed melting.point",data = contract_dat)

abline(v=0,h=0, col = "dark gray")

abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)

with(contract_dat,text(Recons.2 ~ Recons.1, labels =as.factor(rownames(contract_dat)), pos=3))

plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_dat)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19, main="Original Data",data = scaled_dat)

abline(v=0,h=0, col = "dark gray")



abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)
with(scaled_dat,text(melting.point ~ atomic.no, labels = as.factor(rownames(scaled_dat)), pos=3))
